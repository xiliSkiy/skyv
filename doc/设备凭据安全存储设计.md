# 设备凭据安全存储设计方案

## 文档说明
本文档详细说明了SkyEye智能监控系统中设备登录凭据的安全存储设计方案，包括加密策略、存储结构、访问控制等。

---

## 1. 安全需求分析

### 1.1 设备凭据类型
- **用户名密码**：最常见的认证方式
- **SSH密钥对**：Linux设备SSH登录
- **SNMP Community**：SNMP协议认证字符串
- **API Token**：REST API访问令牌
- **证书文件**：SSL/TLS客户端证书
- **自定义认证**：厂商特定的认证信息

### 1.2 安全威胁分析
- **数据库泄露**：数据库被攻击导致凭据泄露
- **内部威胁**：内部人员恶意获取凭据
- **日志泄露**：凭据信息意外记录到日志中
- **内存泄露**：运行时内存中的凭据被获取
- **传输泄露**：网络传输过程中被截获

### 1.3 合规要求
- **数据保护法规**：符合GDPR、网络安全法等要求
- **行业标准**：遵循ISO 27001、SOC 2等安全标准
- **企业安全策略**：满足企业内部安全要求

---

## 2. 加密存储方案

### 2.1 多层加密架构

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层加密                                │
│  ┌─────────────────┐    ┌─────────────────┐                │
│  │   业务密钥      │    │   主密钥        │                │
│  │  (Business Key) │    │ (Master Key)    │                │
│  └─────────────────┘    └─────────────────┘                │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    数据库层加密                              │
│  ┌─────────────────────────────────────────────────────────┤
│  │  PostgreSQL TDE (Transparent Data Encryption)          │
│  └─────────────────────────────────────────────────────────┤
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    操作系统层加密                            │
│  ┌─────────────────────────────────────────────────────────┤
│  │  文件系统加密 (LUKS/BitLocker)                          │
│  └─────────────────────────────────────────────────────────┤
└─────────────────────────────────────────────────────────────┘
```

### 2.2 密钥管理体系

#### 2.2.1 密钥层级结构
```sql
-- 主密钥表（系统级）
CREATE TABLE tb_master_keys (
    id BIGSERIAL PRIMARY KEY,
    key_name VARCHAR(50) UNIQUE NOT NULL COMMENT '密钥名称',
    key_version INTEGER DEFAULT 1 COMMENT '密钥版本',
    encrypted_key TEXT NOT NULL COMMENT '加密后的主密钥',
    key_algorithm VARCHAR(20) DEFAULT 'AES-256' COMMENT '加密算法',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    expires_at TIMESTAMP COMMENT '过期时间',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否激活'
);

-- 业务密钥表（租户级）
CREATE TABLE tb_business_keys (
    id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT COMMENT '租户ID',
    key_name VARCHAR(50) NOT NULL COMMENT '业务密钥名称',
    master_key_id BIGINT REFERENCES tb_master_keys(id) COMMENT '主密钥ID',
    encrypted_key TEXT NOT NULL COMMENT '加密后的业务密钥',
    key_purpose VARCHAR(50) COMMENT '密钥用途',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    rotated_at TIMESTAMP COMMENT '最后轮换时间',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否激活'
);

-- 密钥使用日志
CREATE TABLE tb_key_usage_logs (
    id BIGSERIAL PRIMARY KEY,
    key_id BIGINT COMMENT '密钥ID',
    key_type VARCHAR(20) COMMENT '密钥类型',
    operation VARCHAR(20) COMMENT '操作类型：ENCRYPT,DECRYPT',
    user_id BIGINT COMMENT '操作用户ID',
    device_id BIGINT COMMENT '相关设备ID',
    ip_address INET COMMENT '操作IP',
    success BOOLEAN COMMENT '是否成功',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间'
);
```

#### 2.2.2 密钥轮换策略
```java
@Component
public class KeyRotationService {
    
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void rotateKeys() {
        // 检查需要轮换的密钥
        List<BusinessKey> keysToRotate = findKeysNeedRotation();
        
        for (BusinessKey key : keysToRotate) {
            rotateBusinessKey(key);
        }
    }
    
    private void rotateBusinessKey(BusinessKey oldKey) {
        // 1. 生成新密钥
        String newKeyValue = generateSecureKey();
        
        // 2. 使用主密钥加密新密钥
        String encryptedNewKey = masterKeyService.encrypt(newKeyValue);
        
        // 3. 创建新密钥记录
        BusinessKey newKey = createNewKeyVersion(oldKey, encryptedNewKey);
        
        // 4. 重新加密所有使用旧密钥的凭据
        reEncryptCredentials(oldKey, newKey);
        
        // 5. 标记旧密钥为非激活状态（保留一段时间用于数据恢复）
        deactivateOldKey(oldKey);
        
        // 6. 记录密钥轮换日志
        logKeyRotation(oldKey, newKey);
    }
}
```

---

## 3. 设备凭据存储表设计

### 3.1 凭据存储主表
```sql
-- 设备凭据表
CREATE TABLE tb_device_credentials (
    id BIGSERIAL PRIMARY KEY,
    device_id BIGINT NOT NULL REFERENCES tb_devices(id) ON DELETE CASCADE,
    
    -- 凭据基本信息
    credential_name VARCHAR(100) NOT NULL COMMENT '凭据名称',
    credential_type VARCHAR(50) NOT NULL COMMENT '凭据类型',
    protocol VARCHAR(20) COMMENT '适用协议',
    
    -- 加密存储的凭据数据
    encrypted_data TEXT NOT NULL COMMENT '加密后的凭据数据',
    encryption_key_id BIGINT REFERENCES tb_business_keys(id) COMMENT '加密密钥ID',
    encryption_algorithm VARCHAR(50) DEFAULT 'AES-256-GCM' COMMENT '加密算法',
    data_hash VARCHAR(64) COMMENT '数据完整性校验哈希',
    
    -- 凭据属性
    is_default BOOLEAN DEFAULT FALSE COMMENT '是否默认凭据',
    priority INTEGER DEFAULT 1 COMMENT '优先级',
    
    -- 有效期管理
    valid_from TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '生效时间',
    valid_until TIMESTAMP COMMENT '失效时间',
    
    -- 使用统计
    last_used_at TIMESTAMP COMMENT '最后使用时间',
    success_count BIGINT DEFAULT 0 COMMENT '成功使用次数',
    failure_count BIGINT DEFAULT 0 COMMENT '失败使用次数',
    
    -- 审计信息
    created_by BIGINT REFERENCES tb_users(id) COMMENT '创建人',
    updated_by BIGINT REFERENCES tb_users(id) COMMENT '更新人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
    
    -- 约束
    UNIQUE(device_id, credential_name),
    CHECK (valid_until IS NULL OR valid_until > valid_from)
);

-- 创建索引
CREATE INDEX idx_device_credentials_device ON tb_device_credentials (device_id);
CREATE INDEX idx_device_credentials_type ON tb_device_credentials (credential_type);
CREATE INDEX idx_device_credentials_key ON tb_device_credentials (encryption_key_id);
CREATE INDEX idx_device_credentials_validity ON tb_device_credentials (valid_from, valid_until);

COMMENT ON TABLE tb_device_credentials IS '设备凭据表（加密存储）';
```

### 3.2 凭据模板表
```sql
-- 凭据模板表
CREATE TABLE tb_credential_templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL COMMENT '模板名称',
    device_type_id BIGINT REFERENCES tb_device_types(id) COMMENT '适用设备类型',
    credential_type VARCHAR(50) NOT NULL COMMENT '凭据类型',
    protocol VARCHAR(20) COMMENT '适用协议',
    
    -- 模板定义
    template_schema JSONB NOT NULL COMMENT '凭据字段模板',
    validation_rules JSONB COMMENT '验证规则',
    default_values JSONB COMMENT '默认值',
    
    -- 安全配置
    encryption_required BOOLEAN DEFAULT TRUE COMMENT '是否需要加密',
    min_key_length INTEGER COMMENT '最小密钥长度',
    password_policy JSONB COMMENT '密码策略',
    
    -- 模板属性
    is_system BOOLEAN DEFAULT FALSE COMMENT '是否系统模板',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否激活',
    
    created_by BIGINT REFERENCES tb_users(id) COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间'
);

-- 初始化凭据模板
INSERT INTO tb_credential_templates (name, credential_type, protocol, template_schema, is_system) VALUES
('SSH用户名密码', 'USERNAME_PASSWORD', 'SSH', '{
    "fields": [
        {"name": "username", "type": "string", "required": true, "label": "用户名"},
        {"name": "password", "type": "password", "required": true, "label": "密码", "encrypted": true}
    ]
}', TRUE),

('SSH密钥对', 'SSH_KEY', 'SSH', '{
    "fields": [
        {"name": "username", "type": "string", "required": true, "label": "用户名"},
        {"name": "private_key", "type": "text", "required": true, "label": "私钥", "encrypted": true},
        {"name": "passphrase", "type": "password", "required": false, "label": "密钥密码", "encrypted": true}
    ]
}', TRUE),

('SNMP Community', 'SNMP_COMMUNITY', 'SNMP', '{
    "fields": [
        {"name": "community", "type": "string", "required": true, "label": "Community字符串", "encrypted": true},
        {"name": "version", "type": "select", "required": true, "label": "SNMP版本", "options": ["v1", "v2c", "v3"]}
    ]
}', TRUE),

('SNMP v3', 'SNMP_V3', 'SNMP', '{
    "fields": [
        {"name": "username", "type": "string", "required": true, "label": "用户名"},
        {"name": "auth_protocol", "type": "select", "required": false, "label": "认证协议", "options": ["MD5", "SHA"]},
        {"name": "auth_password", "type": "password", "required": false, "label": "认证密码", "encrypted": true},
        {"name": "priv_protocol", "type": "select", "required": false, "label": "加密协议", "options": ["DES", "AES"]},
        {"name": "priv_password", "type": "password", "required": false, "label": "加密密码", "encrypted": true}
    ]
}', TRUE),

('HTTP Basic Auth', 'HTTP_BASIC', 'HTTP', '{
    "fields": [
        {"name": "username", "type": "string", "required": true, "label": "用户名"},
        {"name": "password", "type": "password", "required": true, "label": "密码", "encrypted": true}
    ]
}', TRUE),

('API Token', 'API_TOKEN', 'HTTP', '{
    "fields": [
        {"name": "token", "type": "password", "required": true, "label": "API Token", "encrypted": true},
        {"name": "token_type", "type": "select", "required": false, "label": "Token类型", "options": ["Bearer", "Basic", "Custom"]}
    ]
}', TRUE);

COMMENT ON TABLE tb_credential_templates IS '凭据模板表';
```

### 3.3 凭据使用日志表
```sql
-- 凭据使用日志表
CREATE TABLE tb_credential_usage_logs (
    id BIGSERIAL PRIMARY KEY,
    credential_id BIGINT REFERENCES tb_device_credentials(id) ON DELETE CASCADE,
    device_id BIGINT REFERENCES tb_devices(id) COMMENT '设备ID',
    
    -- 使用信息
    operation VARCHAR(50) COMMENT '操作类型',
    collector_id BIGINT REFERENCES tb_collectors(id) COMMENT '采集器ID',
    task_id BIGINT REFERENCES tb_collection_tasks(id) COMMENT '任务ID',
    
    -- 结果信息
    success BOOLEAN NOT NULL COMMENT '是否成功',
    error_code VARCHAR(50) COMMENT '错误代码',
    error_message TEXT COMMENT '错误信息',
    response_time INTEGER COMMENT '响应时间(毫秒)',
    
    -- 安全信息
    source_ip INET COMMENT '来源IP',
    user_agent TEXT COMMENT '用户代理',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '使用时间'
) PARTITION BY RANGE (created_at);

-- 创建分区表
CREATE TABLE tb_credential_usage_logs_y2024m01 PARTITION OF tb_credential_usage_logs
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 创建索引
CREATE INDEX idx_credential_usage_logs_credential ON tb_credential_usage_logs (credential_id, created_at DESC);
CREATE INDEX idx_credential_usage_logs_device ON tb_credential_usage_logs (device_id, created_at DESC);
CREATE INDEX idx_credential_usage_logs_success ON tb_credential_usage_logs (success, created_at DESC);

COMMENT ON TABLE tb_credential_usage_logs IS '凭据使用日志表';
```

---

## 4. Java实现方案

### 4.1 加密服务实现
```java
@Service
@Slf4j
public class CredentialEncryptionService {
    
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    @Autowired
    private KeyManagementService keyManagementService;
    
    /**
     * 加密凭据数据
     */
    public EncryptedCredential encrypt(String plainData, Long keyId) {
        try {
            // 获取业务密钥
            String businessKey = keyManagementService.getBusinessKey(keyId);
            
            // 生成随机IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            SecureRandom.getInstanceStrong().nextBytes(iv);
            
            // 初始化加密器
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            SecretKeySpec keySpec = new SecretKeySpec(
                Base64.getDecoder().decode(businessKey), "AES");
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, parameterSpec);
            
            // 执行加密
            byte[] encryptedData = cipher.doFinal(plainData.getBytes(StandardCharsets.UTF_8));
            
            // 组合IV和加密数据
            byte[] encryptedWithIv = new byte[GCM_IV_LENGTH + encryptedData.length];
            System.arraycopy(iv, 0, encryptedWithIv, 0, GCM_IV_LENGTH);
            System.arraycopy(encryptedData, 0, encryptedWithIv, GCM_IV_LENGTH, encryptedData.length);
            
            // 计算数据哈希用于完整性校验
            String dataHash = DigestUtils.sha256Hex(plainData);
            
            return EncryptedCredential.builder()
                .encryptedData(Base64.getEncoder().encodeToString(encryptedWithIv))
                .keyId(keyId)
                .algorithm(ALGORITHM)
                .dataHash(dataHash)
                .build();
                
        } catch (Exception e) {
            log.error("Failed to encrypt credential data", e);
            throw new CredentialEncryptionException("加密失败", e);
        }
    }
    
    /**
     * 解密凭据数据
     */
    public String decrypt(EncryptedCredential encryptedCredential) {
        try {
            // 获取业务密钥
            String businessKey = keyManagementService.getBusinessKey(encryptedCredential.getKeyId());
            
            // 解码加密数据
            byte[] encryptedWithIv = Base64.getDecoder().decode(encryptedCredential.getEncryptedData());
            
            // 分离IV和加密数据
            byte[] iv = new byte[GCM_IV_LENGTH];
            byte[] encryptedData = new byte[encryptedWithIv.length - GCM_IV_LENGTH];
            System.arraycopy(encryptedWithIv, 0, iv, 0, GCM_IV_LENGTH);
            System.arraycopy(encryptedWithIv, GCM_IV_LENGTH, encryptedData, 0, encryptedData.length);
            
            // 初始化解密器
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            SecretKeySpec keySpec = new SecretKeySpec(
                Base64.getDecoder().decode(businessKey), "AES");
            cipher.init(Cipher.DECRYPT_MODE, keySpec, parameterSpec);
            
            // 执行解密
            byte[] decryptedData = cipher.doFinal(encryptedData);
            String plainData = new String(decryptedData, StandardCharsets.UTF_8);
            
            // 验证数据完整性
            String calculatedHash = DigestUtils.sha256Hex(plainData);
            if (!calculatedHash.equals(encryptedCredential.getDataHash())) {
                throw new CredentialIntegrityException("数据完整性校验失败");
            }
            
            return plainData;
            
        } catch (Exception e) {
            log.error("Failed to decrypt credential data", e);
            throw new CredentialDecryptionException("解密失败", e);
        }
    }
}
```

### 4.2 凭据管理服务
```java
@Service
@Transactional
@Slf4j
public class DeviceCredentialService {
    
    @Autowired
    private DeviceCredentialRepository credentialRepository;
    
    @Autowired
    private CredentialEncryptionService encryptionService;
    
    @Autowired
    private CredentialUsageLogService usageLogService;
    
    /**
     * 保存设备凭据
     */
    public DeviceCredential saveCredential(Long deviceId, CredentialRequest request) {
        // 验证权限
        validatePermission(deviceId, "CREDENTIAL_MANAGE");
        
        // 构建凭据数据JSON
        Map<String, Object> credentialData = buildCredentialData(request);
        String credentialJson = JsonUtils.toJson(credentialData);
        
        // 加密凭据数据
        Long keyId = keyManagementService.getCurrentBusinessKeyId();
        EncryptedCredential encrypted = encryptionService.encrypt(credentialJson, keyId);
        
        // 创建凭据记录
        DeviceCredential credential = DeviceCredential.builder()
            .deviceId(deviceId)
            .credentialName(request.getName())
            .credentialType(request.getType())
            .protocol(request.getProtocol())
            .encryptedData(encrypted.getEncryptedData())
            .encryptionKeyId(encrypted.getKeyId())
            .encryptionAlgorithm(encrypted.getAlgorithm())
            .dataHash(encrypted.getDataHash())
            .isDefault(request.isDefault())
            .priority(request.getPriority())
            .validFrom(request.getValidFrom())
            .validUntil(request.getValidUntil())
            .createdBy(getCurrentUserId())
            .build();
        
        // 保存到数据库
        credential = credentialRepository.save(credential);
        
        // 记录操作日志
        logCredentialOperation("CREATE", credential.getId(), "创建设备凭据");
        
        return credential;
    }
    
    /**
     * 获取设备凭据（解密）
     */
    public Map<String, Object> getCredentialData(Long credentialId) {
        // 验证权限
        validateCredentialAccess(credentialId);
        
        // 查询凭据记录
        DeviceCredential credential = credentialRepository.findById(credentialId)
            .orElseThrow(() -> new CredentialNotFoundException("凭据不存在"));
        
        // 检查有效期
        if (!isCredentialValid(credential)) {
            throw new CredentialExpiredException("凭据已过期");
        }
        
        try {
            // 构建加密凭据对象
            EncryptedCredential encrypted = EncryptedCredential.builder()
                .encryptedData(credential.getEncryptedData())
                .keyId(credential.getEncryptionKeyId())
                .algorithm(credential.getEncryptionAlgorithm())
                .dataHash(credential.getDataHash())
                .build();
            
            // 解密凭据数据
            String credentialJson = encryptionService.decrypt(encrypted);
            Map<String, Object> credentialData = JsonUtils.fromJson(credentialJson, Map.class);
            
            // 记录使用日志
            usageLogService.logCredentialUsage(credentialId, "DECRYPT", true, null);
            
            return credentialData;
            
        } catch (Exception e) {
            // 记录失败日志
            usageLogService.logCredentialUsage(credentialId, "DECRYPT", false, e.getMessage());
            throw e;
        }
    }
    
    /**
     * 获取设备的默认凭据
     */
    public Map<String, Object> getDefaultCredential(Long deviceId, String protocol) {
        DeviceCredential credential = credentialRepository
            .findByDeviceIdAndProtocolAndIsDefaultTrue(deviceId, protocol)
            .orElseThrow(() -> new CredentialNotFoundException("未找到默认凭据"));
        
        return getCredentialData(credential.getId());
    }
    
    /**
     * 测试凭据连接
     */
    public CredentialTestResult testCredential(Long credentialId) {
        // 获取凭据数据
        Map<String, Object> credentialData = getCredentialData(credentialId);
        
        // 获取设备信息
        DeviceCredential credential = credentialRepository.findById(credentialId).get();
        Device device = deviceRepository.findById(credential.getDeviceId()).get();
        
        // 根据协议类型测试连接
        CredentialTestResult result = performConnectionTest(device, credentialData, credential.getProtocol());
        
        // 更新使用统计
        updateCredentialUsageStats(credentialId, result.isSuccess());
        
        // 记录测试日志
        usageLogService.logCredentialUsage(credentialId, "TEST", result.isSuccess(), result.getErrorMessage());
        
        return result;
    }
    
    /**
     * 轮换设备凭据
     */
    public void rotateCredential(Long credentialId, CredentialRequest newCredentialRequest) {
        // 验证权限
        validatePermission(credentialId, "CREDENTIAL_ROTATE");
        
        // 获取原凭据
        DeviceCredential oldCredential = credentialRepository.findById(credentialId)
            .orElseThrow(() -> new CredentialNotFoundException("凭据不存在"));
        
        // 创建新凭据
        DeviceCredential newCredential = saveCredential(oldCredential.getDeviceId(), newCredentialRequest);
        
        // 测试新凭据
        CredentialTestResult testResult = testCredential(newCredential.getId());
        if (!testResult.isSuccess()) {
            // 测试失败，删除新凭据
            credentialRepository.delete(newCredential);
            throw new CredentialTestException("新凭据测试失败: " + testResult.getErrorMessage());
        }
        
        // 标记旧凭据为非默认
        oldCredential.setIsDefault(false);
        oldCredential.setValidUntil(Timestamp.from(Instant.now().plus(7, ChronoUnit.DAYS))); // 保留7天
        credentialRepository.save(oldCredential);
        
        // 设置新凭据为默认
        newCredential.setIsDefault(true);
        credentialRepository.save(newCredential);
        
        // 记录轮换日志
        logCredentialOperation("ROTATE", credentialId, "凭据轮换完成");
    }
    
    private Map<String, Object> buildCredentialData(CredentialRequest request) {
        Map<String, Object> data = new HashMap<>();
        
        // 根据凭据类型构建数据
        switch (request.getType()) {
            case "USERNAME_PASSWORD":
                data.put("username", request.getUsername());
                data.put("password", request.getPassword());
                break;
            case "SSH_KEY":
                data.put("username", request.getUsername());
                data.put("private_key", request.getPrivateKey());
                data.put("passphrase", request.getPassphrase());
                break;
            case "SNMP_COMMUNITY":
                data.put("community", request.getCommunity());
                data.put("version", request.getSnmpVersion());
                break;
            case "API_TOKEN":
                data.put("token", request.getToken());
                data.put("token_type", request.getTokenType());
                break;
            default:
                data.putAll(request.getCustomFields());
        }
        
        return data;
    }
    
    private boolean isCredentialValid(DeviceCredential credential) {
        Timestamp now = Timestamp.from(Instant.now());
        
        if (credential.getValidFrom() != null && now.before(credential.getValidFrom())) {
            return false;
        }
        
        if (credential.getValidUntil() != null && now.after(credential.getValidUntil())) {
            return false;
        }
        
        return true;
    }
}
```

### 4.3 凭据使用记录服务
```java
@Service
@Slf4j
public class CredentialUsageLogService {
    
    @Autowired
    private CredentialUsageLogRepository usageLogRepository;
    
    @Async
    public void logCredentialUsage(Long credentialId, String operation, boolean success, String errorMessage) {
        try {
            CredentialUsageLog log = CredentialUsageLog.builder()
                .credentialId(credentialId)
                .operation(operation)
                .success(success)
                .errorMessage(errorMessage)
                .sourceIp(getCurrentUserIP())
                .userAgent(getCurrentUserAgent())
                .build();
            
            usageLogRepository.save(log);
            
            // 更新凭据使用统计
            updateCredentialStats(credentialId, success);
            
        } catch (Exception e) {
            log.error("Failed to log credential usage", e);
        }
    }
    
    private void updateCredentialStats(Long credentialId, boolean success) {
        if (success) {
            credentialRepository.incrementSuccessCount(credentialId);
        } else {
            credentialRepository.incrementFailureCount(credentialId);
        }
        credentialRepository.updateLastUsedTime(credentialId, Timestamp.from(Instant.now()));
    }
}
```

---

## 5. 安全最佳实践

### 5.1 访问控制
```java
@Component
public class CredentialAccessControl {
    
    /**
     * 验证凭据访问权限
     */
    public void validateCredentialAccess(Long credentialId) {
        UserDetails currentUser = getCurrentUser();
        DeviceCredential credential = credentialRepository.findById(credentialId).orElse(null);
        
        if (credential == null) {
            throw new CredentialNotFoundException("凭据不存在");
        }
        
        // 检查用户是否有权限访问该设备的凭据
        if (!hasDeviceAccess(currentUser.getId(), credential.getDeviceId())) {
            throw new AccessDeniedException("无权限访问该设备凭据");
        }
        
        // 检查用户是否有凭据管理权限
        if (!hasPermission(currentUser, "CREDENTIAL_VIEW")) {
            throw new AccessDeniedException("无凭据查看权限");
        }
        
        // 记录访问日志
        auditService.logCredentialAccess(currentUser.getId(), credentialId, "ACCESS_CHECK");
    }
    
    /**
     * 验证敏感操作权限
     */
    public void validateSensitiveOperation(Long credentialId, String operation) {
        validateCredentialAccess(credentialId);
        
        UserDetails currentUser = getCurrentUser();
        
        // 敏感操作需要更高权限
        switch (operation) {
            case "DECRYPT":
                if (!hasPermission(currentUser, "CREDENTIAL_DECRYPT")) {
                    throw new AccessDeniedException("无凭据解密权限");
                }
                break;
            case "ROTATE":
                if (!hasPermission(currentUser, "CREDENTIAL_ROTATE")) {
                    throw new AccessDeniedException("无凭据轮换权限");
                }
                break;
            case "DELETE":
                if (!hasPermission(currentUser, "CREDENTIAL_DELETE")) {
                    throw new AccessDeniedException("无凭据删除权限");
                }
                break;
        }
        
        // 记录敏感操作
        auditService.logSensitiveOperation(currentUser.getId(), credentialId, operation);
    }
}
```

### 5.2 安全审计
```java
@Service
public class CredentialAuditService {
    
    @Autowired
    private OperationLogRepository operationLogRepository;
    
    /**
     * 记录凭据操作审计日志
     */
    @Async
    public void logCredentialOperation(String operation, Long credentialId, String description) {
        try {
            UserDetails currentUser = getCurrentUser();
            
            OperationLog log = OperationLog.builder()
                .userId(currentUser.getId())
                .username(currentUser.getUsername())
                .module("CREDENTIAL")
                .operation(operation)
                .operationDesc(description)
                .targetType("CREDENTIAL")
                .targetId(credentialId)
                .ipAddress(getCurrentUserIP())
                .userAgent(getCurrentUserAgent())
                .success(true)
                .build();
            
            operationLogRepository.save(log);
            
        } catch (Exception e) {
            log.error("Failed to log credential operation", e);
        }
    }
    
    /**
     * 检测异常访问模式
     */
    @Scheduled(fixedDelay = 300000) // 每5分钟检查一次
    public void detectAnomalousAccess() {
        // 检测短时间内大量凭据访问
        List<Object[]> suspiciousActivity = usageLogRepository.findSuspiciousActivity(
            Timestamp.from(Instant.now().minus(15, ChronoUnit.MINUTES))
        );
        
        for (Object[] activity : suspiciousActivity) {
            Long userId = (Long) activity[0];
            Long accessCount = (Long) activity[1];
            
            if (accessCount > 50) { // 15分钟内访问超过50次凭据
                alertService.sendSecurityAlert(
                    "异常凭据访问检测", 
                    String.format("用户ID %d 在15分钟内访问了 %d 次凭据", userId, accessCount)
                );
            }
        }
        
        // 检测失败率异常
        List<Object[]> highFailureRate = usageLogRepository.findHighFailureRate(
            Timestamp.from(Instant.now().minus(1, ChronoUnit.HOURS))
        );
        
        for (Object[] failure : highFailureRate) {
            Long credentialId = (Long) failure[0];
            Double failureRate = (Double) failure[1];
            
            if (failureRate > 0.5) { // 失败率超过50%
                alertService.sendSecurityAlert(
                    "凭据使用异常", 
                    String.format("凭据ID %d 的使用失败率达到 %.2f%%", credentialId, failureRate * 100)
                );
            }
        }
    }
}
```

### 5.3 内存安全
```java
@Component
public class SecureCredentialHandler {
    
    /**
     * 安全处理凭据数据，使用后立即清除内存
     */
    public <T> T processCredentialSecurely(Long credentialId, Function<Map<String, Object>, T> processor) {
        char[] credentialData = null;
        try {
            // 获取凭据数据
            Map<String, Object> credentials = credentialService.getCredentialData(credentialId);
            
            // 处理凭据数据
            T result = processor.apply(credentials);
            
            return result;
            
        } finally {
            // 立即清除内存中的敏感数据
            if (credentialData != null) {
                Arrays.fill(credentialData, '\0');
            }
            
            // 建议JVM进行垃圾回收
            System.gc();
        }
    }
    
    /**
     * 安全的字符串比较，防止时序攻击
     */
    public boolean secureEquals(String a, String b) {
        if (a == null || b == null) {
            return a == b;
        }
        
        if (a.length() != b.length()) {
            return false;
        }
        
        int result = 0;
        for (int i = 0; i < a.length(); i++) {
            result |= a.charAt(i) ^ b.charAt(i);
        }
        
        return result == 0;
    }
}
```

---

## 6. 监控与告警

### 6.1 安全监控指标
```java
@Component
public class CredentialSecurityMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter credentialAccessCounter;
    private final Counter credentialFailureCounter;
    private final Timer credentialDecryptionTimer;
    
    public CredentialSecurityMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.credentialAccessCounter = Counter.builder("credential.access.total")
            .description("Total credential access attempts")
            .register(meterRegistry);
        this.credentialFailureCounter = Counter.builder("credential.failure.total")
            .description("Total credential access failures")
            .register(meterRegistry);
        this.credentialDecryptionTimer = Timer.builder("credential.decryption.duration")
            .description("Credential decryption duration")
            .register(meterRegistry);
    }
    
    public void recordCredentialAccess(String operation, boolean success) {
        credentialAccessCounter.increment(
            Tags.of(
                "operation", operation,
                "success", String.valueOf(success)
            )
        );
        
        if (!success) {
            credentialFailureCounter.increment(Tags.of("operation", operation));
        }
    }
    
    public void recordDecryptionTime(Duration duration) {
        credentialDecryptionTimer.record(duration);
    }
}
```

### 6.2 告警规则配置
```yaml
# application.yml
app:
  security:
    credential:
      # 告警阈值配置
      alert:
        # 单用户15分钟内访问凭据超过50次
        max-access-per-user-15min: 50
        # 单个凭据1小时内失败率超过50%
        max-failure-rate-1hour: 0.5
        # 解密操作超过5秒告警
        max-decryption-time-ms: 5000
        # 连续失败次数超过10次锁定凭据
        max-consecutive-failures: 10
      
      # 密钥轮换配置
      rotation:
        # 业务密钥轮换周期（天）
        business-key-rotation-days: 90
        # 主密钥轮换周期（天）
        master-key-rotation-days: 365
        # 凭据轮换提醒天数
        credential-rotation-reminder-days: 30
```

---

## 7. 总结

### 7.1 安全特性总结
1. **多层加密**：主密钥 + 业务密钥 + 应用层加密
2. **密钥管理**：完整的密钥生命周期管理和轮换机制
3. **访问控制**：基于角色的细粒度权限控制
4. **数据完整性**：哈希校验确保数据未被篡改
5. **审计跟踪**：完整的操作日志和使用记录
6. **异常检测**：自动检测异常访问模式
7. **内存安全**：敏感数据使用后立即清除
8. **合规支持**：满足数据保护法规要求

### 7.2 实施建议
1. **分阶段实施**：先实现基础加密，再逐步完善高级安全特性
2. **密钥管理**：优先建立密钥管理体系，这是整个安全架构的基础
3. **权限控制**：严格控制凭据访问权限，实施最小权限原则
4. **监控告警**：建立完善的安全监控和告警机制
5. **定期审计**：定期进行安全审计和渗透测试
6. **培训教育**：对开发和运维人员进行安全培训

这个设计方案提供了企业级的设备凭据安全存储解决方案，能够有效保护敏感的设备登录信息，满足各种合规要求。 