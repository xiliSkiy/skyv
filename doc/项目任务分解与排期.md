# SkyEye 智能监控系统 - 项目任务分解与排期

## 文档说明
本文档基于功能需求清单和后端架构设计，将项目分解为可执行的开发任务，每个任务都包含详细的实现说明，便于开发工具理解和实现。

---

## 1. 项目概览

### 1.1 开发周期规划
- **第一阶段**：基础框架与核心功能（4周）
- **第二阶段**：数据采集与任务调度（3周）
- **第三阶段**：监控与报警功能（2周）
- **第四阶段**：系统完善与优化（2周）

### 1.2 优先级说明
- **P0**：核心功能，必须优先完成
- **P1**：重要功能，第一阶段完成
- **P2**：一般功能，第二阶段完成
- **P3**：扩展功能，后续版本完成

---

## 2. 第一阶段：基础框架与核心功能（4周）

### 2.1 项目初始化与基础配置 [P0] - 2天

#### 任务2.1.1：创建Spring Boot项目结构
**描述**：创建基础的Spring Boot项目，配置必要的依赖和项目结构

**实现要求**：
```xml
<!-- pom.xml 主要依赖 -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>
</dependencies>
```

**包结构**：
```
com.skyeye/
├── SkyEyeApplication.java
├── common/
│   ├── config/
│   ├── constant/
│   ├── exception/
│   ├── response/
│   └── util/
├── security/
├── auth/
├── user/
├── device/
├── collector/
├── monitoring/
├── alert/
├── analytics/
├── task/
├── history/
└── system/
```

#### 任务2.1.2：配置数据库连接和Redis
**描述**：配置PostgreSQL和Redis连接，创建基础配置类

**实现要求**：
```yaml
# application.yml
spring:
  application:
    name: skyeye-monitoring
  datasource:
    url: jdbc:postgresql://localhost:5432/skyeye
    username: skyeye_app
    password: skyeye_app_2024
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  redis:
    host: localhost
    port: 6379
    timeout: 2000ms
```

**配置类**：
- `DatabaseConfig.java`：数据库配置
- `RedisConfig.java`：Redis配置
- `JpaConfig.java`：JPA配置

### 2.2 数据库表结构创建 [P0] - 1天

#### 任务2.2.1：执行数据库建表脚本
**描述**：根据数据库设计文档创建所有必要的数据表

**实现要求**：
1. 创建`resources/db/migration/`目录
2. 创建SQL脚本文件：
   - `V1.0.1__create_user_tables.sql` - 用户权限相关表
   - `V1.0.2__create_device_tables.sql` - 设备管理相关表
   - `V1.0.3__create_collector_tables.sql` - 采集器相关表
   - `V1.0.4__create_alert_tables.sql` - 报警相关表
   - `V1.0.5__create_system_tables.sql` - 系统配置相关表
   - `V1.0.6__init_basic_data.sql` - 初始化基础数据

**验证要求**：
- 所有表创建成功
- 索引创建完成
- 分区表配置正确
- 基础数据插入成功

### 2.3 公共模块开发 [P0] - 2天

#### 任务2.3.1：创建公共响应类和异常处理
**描述**：创建统一的API响应格式和全局异常处理机制

**实现要求**：
```java
// ApiResponse.java
@Data
public class ApiResponse<T> {
    private Integer code;
    private String message;
    private T data;
    private Map<String, Object> meta;
    
    public static <T> ApiResponse<T> success(T data) {
        // 实现成功响应
    }
    
    public static <T> ApiResponse<T> error(Integer code, String message) {
        // 实现错误响应
    }
}

// GlobalExceptionHandler.java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        // 处理业务异常
    }
    
    @ExceptionHandler(ValidationException.class)
    public ApiResponse<Void> handleValidationException(ValidationException e) {
        // 处理参数校验异常
    }
}
```

#### 任务2.3.2：创建工具类和常量定义
**描述**：创建项目中需要用到的工具类和常量定义

**实现要求**：
- `DateUtils.java`：日期时间工具类
- `JsonUtils.java`：JSON序列化工具类
- `EncryptionUtils.java`：加密解密工具类
- `Constants.java`：系统常量定义
- `DeviceStatus.java`：设备状态枚举
- `AlertLevel.java`：报警级别枚举

### 2.4 用户认证与权限管理 [P0] - 4天

#### 任务2.4.1：实现JWT认证机制
**描述**：实现基于JWT的用户认证机制

**实现要求**：
```java
// JwtTokenProvider.java
@Component
public class JwtTokenProvider {
    private String secretKey = "skyeye-jwt-secret-key";
    private long validityInMilliseconds = 86400000; // 24小时
    
    public String createToken(String username, List<String> roles) {
        // 创建JWT Token
    }
    
    public boolean validateToken(String token) {
        // 验证Token有效性
    }
    
    public String getUsername(String token) {
        // 从Token获取用户名
    }
}

// JwtAuthenticationFilter.java
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) {
        // JWT Token过滤逻辑
    }
}
```

#### 任务2.4.2：实现用户管理功能
**描述**：实现用户CRUD操作和权限管理

**实体类**：
```java
// User.java
@Entity
@Table(name = "tb_users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String password;
    
    // 其他字段...
}

// Role.java
@Entity
@Table(name = "tb_roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    // 其他字段...
}
```

**服务类**：
```java
// UserService.java
@Service
@Transactional
public class UserService {
    public User createUser(UserCreateRequest request) {
        // 创建用户逻辑
    }
    
    public User updateUser(Long id, UserUpdateRequest request) {
        // 更新用户逻辑
    }
    
    public void deleteUser(Long id) {
        // 删除用户逻辑
    }
    
    public Page<User> getUsers(UserQueryRequest request) {
        // 分页查询用户
    }
}
```

**控制器**：
```java
// UserController.java
@RestController
@RequestMapping("/api/users")
public class UserController {
    @PostMapping
    public ApiResponse<User> createUser(@Valid @RequestBody UserCreateRequest request) {
        // 创建用户接口
    }
    
    @GetMapping
    public ApiResponse<Page<User>> getUsers(@ModelAttribute UserQueryRequest request) {
        // 查询用户列表接口
    }
}
```

#### 任务2.4.3：实现登录认证接口
**描述**：实现用户登录、登出、密码重置等认证接口

**实现要求**：
```java
// AuthController.java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    @PostMapping("/login")
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        // 用户登录逻辑
        // 1. 验证用户名密码
        // 2. 生成JWT Token
        // 3. 记录登录日志
        // 4. 返回用户信息和Token
    }
    
    @PostMapping("/logout")
    public ApiResponse<Void> logout(HttpServletRequest request) {
        // 用户登出逻辑
        // 1. 获取Token
        // 2. 将Token加入黑名单
        // 3. 记录登出日志
    }
    
    @PostMapping("/refresh")
    public ApiResponse<LoginResponse> refreshToken(@RequestBody RefreshTokenRequest request) {
        // 刷新Token逻辑
    }
}
```

### 2.5 设备管理核心功能 [P0] - 5天

#### 任务2.5.1：实现设备基础实体和仓库
**描述**：创建设备相关的实体类、DTO和Repository

**实体类**：
```java
// Device.java
@Entity
@Table(name = "tb_devices")
public class Device {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "device_type_id")
    private DeviceType deviceType;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "area_id")
    private DeviceArea area;
    
    @Column(name = "ip_address")
    private String ipAddress;
    
    private Integer port;
    private String protocol;
    private Integer status; // 1:在线 0:离线 2:故障
    
    @Type(JsonType.class)
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> config;
    
    // 其他字段和方法...
}

// DeviceType.java
@Entity
@Table(name = "tb_device_types")
public class DeviceType {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String code;
    
    // 树形结构
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private DeviceType parent;
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<DeviceType> children = new ArrayList<>();
    
    // 其他字段...
}
```

**Repository接口**：
```java
// DeviceRepository.java
@Repository
public interface DeviceRepository extends JpaRepository<Device, Long>, JpaSpecificationExecutor<Device> {
    List<Device> findByStatus(Integer status);
    List<Device> findByDeviceTypeId(Long deviceTypeId);
    List<Device> findByAreaId(Long areaId);
    
    @Query("SELECT d FROM Device d WHERE d.name LIKE %:name%")
    List<Device> findByNameContaining(@Param("name") String name);
    
    @Query(value = "SELECT COUNT(*) FROM tb_devices WHERE status = :status", nativeQuery = true)
    Long countByStatus(@Param("status") Integer status);
}
```

#### 任务2.5.2：实现设备管理服务层
**描述**：实现设备的CRUD操作和业务逻辑

**服务类**：
```java
// DeviceService.java
@Service
@Transactional
public class DeviceService {
    
    @Autowired
    private DeviceRepository deviceRepository;
    
    @Autowired
    private DeviceTypeRepository deviceTypeRepository;
    
    public Device createDevice(DeviceCreateRequest request) {
        // 1. 验证设备类型是否存在
        DeviceType deviceType = deviceTypeRepository.findById(request.getDeviceTypeId())
            .orElseThrow(() -> new BusinessException("设备类型不存在"));
        
        // 2. 验证IP地址是否重复
        if (request.getIpAddress() != null) {
            boolean exists = deviceRepository.existsByIpAddress(request.getIpAddress());
            if (exists) {
                throw new BusinessException("IP地址已存在");
            }
        }
        
        // 3. 创建设备对象
        Device device = new Device();
        device.setName(request.getName());
        device.setDeviceType(deviceType);
        device.setIpAddress(request.getIpAddress());
        device.setPort(request.getPort());
        device.setProtocol(request.getProtocol());
        device.setStatus(1); // 默认在线状态
        device.setConfig(request.getConfig());
        device.setLocation(request.getLocation());
        device.setDescription(request.getDescription());
        
        // 4. 保存设备
        device = deviceRepository.save(device);
        
        // 5. 记录操作日志
        operationLogService.log("DEVICE", "CREATE", device.getId(), "创建设备: " + device.getName());
        
        return device;
    }
    
    public Device updateDevice(Long id, DeviceUpdateRequest request) {
        // 更新设备逻辑
        Device device = deviceRepository.findById(id)
            .orElseThrow(() -> new BusinessException("设备不存在"));
        
        // 更新字段
        if (request.getName() != null) {
            device.setName(request.getName());
        }
        // ... 其他字段更新
        
        device = deviceRepository.save(device);
        
        // 记录操作日志
        operationLogService.log("DEVICE", "UPDATE", device.getId(), "更新设备: " + device.getName());
        
        return device;
    }
    
    public void deleteDevice(Long id) {
        Device device = deviceRepository.findById(id)
            .orElseThrow(() -> new BusinessException("设备不存在"));
        
        // 检查是否有关联的采集任务
        boolean hasCollectionTasks = collectionTaskRepository.existsByDeviceId(id);
        if (hasCollectionTasks) {
            throw new BusinessException("设备存在关联的采集任务，无法删除");
        }
        
        deviceRepository.deleteById(id);
        
        // 记录操作日志
        operationLogService.log("DEVICE", "DELETE", id, "删除设备: " + device.getName());
    }
    
    public Page<Device> getDevices(DeviceQueryRequest request) {
        // 构建查询条件
        Specification<Device> spec = (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (request.getName() != null && !request.getName().isEmpty()) {
                predicates.add(criteriaBuilder.like(root.get("name"), "%" + request.getName() + "%"));
            }
            
            if (request.getDeviceTypeId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("deviceType").get("id"), request.getDeviceTypeId()));
            }
            
            if (request.getStatus() != null) {
                predicates.add(criteriaBuilder.equal(root.get("status"), request.getStatus()));
            }
            
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
        
        // 构建分页和排序
        Pageable pageable = PageRequest.of(
            request.getPage() - 1, 
            request.getSize(),
            Sort.by(Sort.Direction.DESC, "updatedAt")
        );
        
        return deviceRepository.findAll(spec, pageable);
    }
    
    public DeviceStatusStatistics getDeviceStatistics() {
        Long totalCount = deviceRepository.count();
        Long onlineCount = deviceRepository.countByStatus(1);
        Long offlineCount = deviceRepository.countByStatus(0);
        Long faultCount = deviceRepository.countByStatus(2);
        
        return DeviceStatusStatistics.builder()
            .totalCount(totalCount)
            .onlineCount(onlineCount)
            .offlineCount(offlineCount)
            .faultCount(faultCount)
            .build();
    }
}
```

#### 任务2.5.3：实现设备管理控制器
**描述**：实现设备管理的REST API接口

**控制器**：
```java
// DeviceController.java
@RestController
@RequestMapping("/api/devices")
@PreAuthorize("hasRole('USER')")
public class DeviceController {
    
    @Autowired
    private DeviceService deviceService;
    
    @PostMapping
    @PreAuthorize("hasPermission('device', 'create')")
    public ApiResponse<Device> createDevice(@Valid @RequestBody DeviceCreateRequest request) {
        Device device = deviceService.createDevice(request);
        return ApiResponse.success(device);
    }
    
    @GetMapping
    @PreAuthorize("hasPermission('device', 'view')")
    public ApiResponse<Page<Device>> getDevices(@ModelAttribute DeviceQueryRequest request) {
        Page<Device> devices = deviceService.getDevices(request);
        return ApiResponse.success(devices);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('device', 'view')")
    public ApiResponse<Device> getDevice(@PathVariable Long id) {
        Device device = deviceService.getDeviceById(id);
        return ApiResponse.success(device);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasPermission('device', 'update')")
    public ApiResponse<Device> updateDevice(@PathVariable Long id, 
                                          @Valid @RequestBody DeviceUpdateRequest request) {
        Device device = deviceService.updateDevice(id, request);
        return ApiResponse.success(device);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('device', 'delete')")
    public ApiResponse<Void> deleteDevice(@PathVariable Long id) {
        deviceService.deleteDevice(id);
        return ApiResponse.success(null);
    }
    
    @GetMapping("/statistics")
    @PreAuthorize("hasPermission('device', 'view')")
    public ApiResponse<DeviceStatusStatistics> getDeviceStatistics() {
        DeviceStatusStatistics statistics = deviceService.getDeviceStatistics();
        return ApiResponse.success(statistics);
    }
    
    @PostMapping("/{id}/test")
    @PreAuthorize("hasPermission('device', 'test')")
    public ApiResponse<DeviceTestResult> testDevice(@PathVariable Long id) {
        DeviceTestResult result = deviceService.testDeviceConnection(id);
        return ApiResponse.success(result);
    }
}
```

#### 任务2.5.4：实现设备类型管理
**描述**：实现设备类型的树形结构管理

**服务类**：
```java
// DeviceTypeService.java
@Service
@Transactional
public class DeviceTypeService {
    
    public List<DeviceTypeTreeNode> getDeviceTypeTree() {
        List<DeviceType> allTypes = deviceTypeRepository.findAll();
        return buildTree(allTypes, null);
    }
    
    private List<DeviceTypeTreeNode> buildTree(List<DeviceType> allTypes, Long parentId) {
        return allTypes.stream()
            .filter(type -> Objects.equals(type.getParentId(), parentId))
            .map(type -> {
                DeviceTypeTreeNode node = new DeviceTypeTreeNode();
                node.setId(type.getId());
                node.setName(type.getName());
                node.setCode(type.getCode());
                node.setChildren(buildTree(allTypes, type.getId()));
                return node;
            })
            .collect(Collectors.toList());
    }
    
    public DeviceType createDeviceType(DeviceTypeCreateRequest request) {
        // 创建设备类型逻辑
    }
}
```

---

## 3. 第二阶段：数据采集与任务调度（3周）

### 3.1 设备凭据管理 [P0] - 3天

#### 任务3.1.1：实现设备凭据加密存储
**描述**：实现设备登录凭据的安全存储和管理

**实现要求**：
```java
// DeviceCredential.java
@Entity
@Table(name = "tb_device_credentials")
public class DeviceCredential {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "device_id", nullable = false)
    private Long deviceId;
    
    @Column(name = "credential_name", nullable = false)
    private String credentialName;
    
    @Column(name = "credential_type", nullable = false)
    private String credentialType;
    
    @Column(name = "encrypted_data", nullable = false)
    private String encryptedData;
    
    @Column(name = "encryption_key_id")
    private Long encryptionKeyId;
    
    // 其他字段...
}

// CredentialEncryptionService.java
@Service
public class CredentialEncryptionService {
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    
    public EncryptedCredential encrypt(String plainData, Long keyId) {
        // AES-256-GCM加密实现
    }
    
    public String decrypt(EncryptedCredential encryptedCredential) {
        // 解密实现
    }
}

// DeviceCredentialService.java
@Service
@Transactional
public class DeviceCredentialService {
    public DeviceCredential saveCredential(Long deviceId, CredentialRequest request) {
        // 保存加密凭据
    }
    
    public Map<String, Object> getCredentialData(Long credentialId) {
        // 获取解密后的凭据数据
    }
    
    public Map<String, Object> getDefaultCredential(Long deviceId, String protocol) {
        // 获取设备默认凭据
    }
}
```

### 3.2 数据采集引擎 [P0] - 5天

#### 任务3.2.1：设计采集插件接口
**描述**：设计可扩展的数据采集插件接口

**实现要求**：
```java
// CollectorPlugin.java
public interface CollectorPlugin {
    String getPluginType();
    boolean supports(DeviceType deviceType);
    CollectionResult collect(Device device, MetricConfig config);
    void initialize(CollectorConfig config);
    void destroy();
}

// CollectionResult.java
@Data
@Builder
public class CollectionResult {
    private boolean success;
    private Map<String, Object> metrics;
    private String errorMessage;
    private long timestamp;
    private int qualityScore;
}

// MetricConfig.java
@Data
public class MetricConfig {
    private String metricName;
    private String metricType;
    private Map<String, Object> parameters;
    private int timeout;
    private int retryTimes;
}
```

#### 任务3.2.2：实现SNMP采集插件
**描述**：实现SNMP协议的数据采集插件

**实现要求**：
```java
// SnmpCollectorPlugin.java
@Component
public class SnmpCollectorPlugin implements CollectorPlugin {
    
    @Override
    public String getPluginType() {
        return "SNMP";
    }
    
    @Override
    public boolean supports(DeviceType deviceType) {
        // 检查设备类型是否支持SNMP
        return deviceType.getProtocolTypes().contains("SNMP");
    }
    
    @Override
    public CollectionResult collect(Device device, MetricConfig config) {
        try {
            // 1. 获取设备SNMP凭据
            Map<String, Object> credentials = credentialService.getDefaultCredential(device.getId(), "SNMP");
            
            // 2. 建立SNMP连接
            Snmp snmp = createSnmpSession(device, credentials);
            
            // 3. 执行SNMP查询
            Map<String, Object> metrics = new HashMap<>();
            String oid = (String) config.getParameters().get("oid");
            
            ResponseEvent response = snmp.get(new PDU(), createTarget(device, credentials));
            if (response.getResponse() != null) {
                VariableBinding vb = response.getResponse().get(0);
                metrics.put(config.getMetricName(), vb.getVariable().toString());
            }
            
            return CollectionResult.builder()
                .success(true)
                .metrics(metrics)
                .timestamp(System.currentTimeMillis())
                .qualityScore(100)
                .build();
                
        } catch (Exception e) {
            return CollectionResult.builder()
                .success(false)
                .errorMessage(e.getMessage())
                .timestamp(System.currentTimeMillis())
                .build();
        }
    }
    
    private Snmp createSnmpSession(Device device, Map<String, Object> credentials) {
        // SNMP会话创建逻辑
    }
    
    private Target createTarget(Device device, Map<String, Object> credentials) {
        // SNMP目标创建逻辑
    }
}
```

#### 任务3.2.3：实现HTTP采集插件
**描述**：实现HTTP/REST API的数据采集插件

**实现要求**：
```java
// HttpCollectorPlugin.java
@Component
public class HttpCollectorPlugin implements CollectorPlugin {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Override
    public String getPluginType() {
        return "HTTP";
    }
    
    @Override
    public CollectionResult collect(Device device, MetricConfig config) {
        try {
            // 1. 获取HTTP认证凭据
            Map<String, Object> credentials = credentialService.getDefaultCredential(device.getId(), "HTTP");
            
            // 2. 构建HTTP请求
            String url = buildUrl(device, config);
            HttpHeaders headers = buildHeaders(credentials, config);
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            // 3. 执行HTTP请求
            ResponseEntity<String> response = restTemplate.exchange(
                url, HttpMethod.GET, entity, String.class);
            
            // 4. 解析响应数据
            Map<String, Object> metrics = parseResponse(response.getBody(), config);
            
            return CollectionResult.builder()
                .success(true)
                .metrics(metrics)
                .timestamp(System.currentTimeMillis())
                .qualityScore(100)
                .build();
                
        } catch (Exception e) {
            return CollectionResult.builder()
                .success(false)
                .errorMessage(e.getMessage())
                .timestamp(System.currentTimeMillis())
                .build();
        }
    }
    
    private String buildUrl(Device device, MetricConfig config) {
        // URL构建逻辑
    }
    
    private HttpHeaders buildHeaders(Map<String, Object> credentials, MetricConfig config) {
        // HTTP头构建逻辑，包含认证信息
    }
    
    private Map<String, Object> parseResponse(String responseBody, MetricConfig config) {
        // 响应数据解析逻辑
    }
}
```

#### 任务3.2.4：实现采集引擎管理器
**描述**：实现采集插件的管理和调度

**实现要求**：
```java
// CollectorEngine.java
@Component
public class CollectorEngine {
    
    private final Map<String, CollectorPlugin> plugins = new ConcurrentHashMap<>();
    
    @Autowired
    private List<CollectorPlugin> collectorPlugins;
    
    @PostConstruct
    public void initializePlugins() {
        for (CollectorPlugin plugin : collectorPlugins) {
            registerPlugin(plugin);
        }
    }
    
    public void registerPlugin(CollectorPlugin plugin) {
        plugins.put(plugin.getPluginType(), plugin);
        plugin.initialize(null); // 可以传入配置
    }
    
    public CollectionResult executeCollection(Device device, MetricConfig config) {
        // 1. 根据设备协议选择采集插件
        CollectorPlugin plugin = selectPlugin(device);
        if (plugin == null) {
            return CollectionResult.builder()
                .success(false)
                .errorMessage("未找到适合的采集插件")
                .timestamp(System.currentTimeMillis())
                .build();
        }
        
        // 2. 执行数据采集
        CollectionResult result = plugin.collect(device, config);
        
        // 3. 记录采集日志
        collectionLogService.logCollection(device.getId(), config.getMetricName(), result);
        
        // 4. 保存采集数据
        if (result.isSuccess()) {
            saveCollectionData(device.getId(), config, result);
        }
        
        return result;
    }
    
    private CollectorPlugin selectPlugin(Device device) {
        return plugins.values().stream()
            .filter(plugin -> plugin.supports(device.getDeviceType()))
            .findFirst()
            .orElse(null);
    }
    
    private void saveCollectionData(Long deviceId, MetricConfig config, CollectionResult result) {
        for (Map.Entry<String, Object> entry : result.getMetrics().entrySet()) {
            CollectionData data = new CollectionData();
            data.setDeviceId(deviceId);
            data.setMetricName(entry.getKey());
            data.setMetricValue(parseNumericValue(entry.getValue()));
            data.setMetricData(JsonUtils.toJson(entry.getValue()));
            data.setCollectedAt(new Timestamp(result.getTimestamp()));
            data.setQualityScore(result.getQualityScore());
            
            collectionDataRepository.save(data);
        }
    }
}
```

### 3.3 任务调度系统 [P0] - 4天

#### 任务3.3.1：实现采集任务管理
**描述**：实现采集任务的创建、配置和管理

**实现要求**：
```java
// CollectionTask.java
@Entity
@Table(name = "tb_collection_tasks")
public class CollectionTask {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    private String description;
    
    @Column(name = "collector_id")
    private Long collectorId;
    
    @Column(name = "schedule_type", nullable = false)
    private String scheduleType; // SIMPLE, CRON, EVENT
    
    @Type(JsonType.class)
    @Column(name = "schedule_config", columnDefinition = "jsonb")
    private Map<String, Object> scheduleConfig;
    
    @Type(JsonType.class)
    @Column(name = "target_devices", columnDefinition = "jsonb")
    private List<Long> targetDevices;
    
    @Type(JsonType.class)
    @Column(name = "metrics_config", columnDefinition = "jsonb")
    private List<MetricConfig> metricsConfig;
    
    private Integer status; // 1:启用 0:禁用 2:暂停
    
    // 其他字段...
}

// CollectionTaskService.java
@Service
@Transactional
public class CollectionTaskService {
    
    public CollectionTask createTask(TaskCreateRequest request) {
        // 1. 验证目标设备
        List<Device> devices = deviceRepository.findAllById(request.getTargetDevices());
        if (devices.size() != request.getTargetDevices().size()) {
            throw new BusinessException("部分目标设备不存在");
        }
        
        // 2. 验证指标配置
        validateMetricsConfig(request.getMetricsConfig());
        
        // 3. 创建任务
        CollectionTask task = new CollectionTask();
        task.setName(request.getName());
        task.setDescription(request.getDescription());
        task.setScheduleType(request.getScheduleType());
        task.setScheduleConfig(request.getScheduleConfig());
        task.setTargetDevices(request.getTargetDevices());
        task.setMetricsConfig(request.getMetricsConfig());
        task.setStatus(1); // 默认启用
        
        task = collectionTaskRepository.save(task);
        
        // 4. 注册到调度器
        taskScheduler.scheduleTask(task);
        
        return task;
    }
    
    public void executeTask(Long taskId) {
        CollectionTask task = collectionTaskRepository.findById(taskId)
            .orElseThrow(() -> new BusinessException("任务不存在"));
        
        // 异步执行任务
        taskExecutor.execute(() -> doExecuteTask(task));
    }
    
    private void doExecuteTask(CollectionTask task) {
        String executionId = UUID.randomUUID().toString();
        Timestamp startTime = new Timestamp(System.currentTimeMillis());
        
        try {
            // 1. 记录执行开始
            CollectionLog log = new CollectionLog();
            log.setTaskId(task.getId());
            log.setExecutionId(executionId);
            log.setStartTime(startTime);
            log.setStatus("RUNNING");
            collectionLogRepository.save(log);
            
            // 2. 执行采集任务
            int successCount = 0;
            int failedCount = 0;
            
            for (Long deviceId : task.getTargetDevices()) {
                Device device = deviceRepository.findById(deviceId).orElse(null);
                if (device == null) continue;
                
                for (MetricConfig metricConfig : task.getMetricsConfig()) {
                    CollectionResult result = collectorEngine.executeCollection(device, metricConfig);
                    if (result.isSuccess()) {
                        successCount++;
                    } else {
                        failedCount++;
                    }
                }
            }
            
            // 3. 更新执行结果
            log.setEndTime(new Timestamp(System.currentTimeMillis()));
            log.setStatus("COMPLETED");
            log.setSuccessCount(successCount);
            log.setFailedCount(failedCount);
            collectionLogRepository.save(log);
            
            // 4. 更新任务统计
            updateTaskStatistics(task.getId(), true);
            
        } catch (Exception e) {
            // 记录执行失败
            CollectionLog log = collectionLogRepository.findByExecutionId(executionId);
            if (log != null) {
                log.setEndTime(new Timestamp(System.currentTimeMillis()));
                log.setStatus("FAILED");
                log.setErrorMessage(e.getMessage());
                collectionLogRepository.save(log);
            }
            
            updateTaskStatistics(task.getId(), false);
        }
    }
}
```

#### 任务3.3.2：实现任务调度器
**描述**：实现基于时间和事件的任务调度

**实现要求**：
```java
// TaskScheduler.java
@Component
public class TaskScheduler {
    
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);
    private final Map<Long, ScheduledFuture<?>> scheduledTasks = new ConcurrentHashMap<>();
    
    @Autowired
    private CollectionTaskService taskService;
    
    public void scheduleTask(CollectionTask task) {
        // 取消之前的调度
        cancelTask(task.getId());
        
        switch (task.getScheduleType()) {
            case "SIMPLE":
                scheduleSimpleTask(task);
                break;
            case "CRON":
                scheduleCronTask(task);
                break;
            case "EVENT":
                scheduleEventTask(task);
                break;
        }
    }
    
    private void scheduleSimpleTask(CollectionTask task) {
        Map<String, Object> config = task.getScheduleConfig();
        String frequency = (String) config.get("frequency");
        Integer interval = (Integer) config.get("interval");
        
        long period;
        switch (frequency) {
            case "minutes":
                period = interval * 60;
                break;
            case "hours":
                period = interval * 3600;
                break;
            case "days":
                period = interval * 86400;
                break;
            default:
                throw new IllegalArgumentException("不支持的频率类型: " + frequency);
        }
        
        ScheduledFuture<?> future = scheduler.scheduleAtFixedRate(
            () -> taskService.executeTask(task.getId()),
            0, period, TimeUnit.SECONDS
        );
        
        scheduledTasks.put(task.getId(), future);
    }
    
    private void scheduleCronTask(CollectionTask task) {
        // 实现Cron表达式调度
        String cronExpression = (String) task.getScheduleConfig().get("cronExpression");
        // 使用Spring的CronSequenceGenerator或第三方库实现
    }
    
    public void cancelTask(Long taskId) {
        ScheduledFuture<?> future = scheduledTasks.remove(taskId);
        if (future != null) {
            future.cancel(false);
        }
    }
    
    @PreDestroy
    public void shutdown() {
        scheduler.shutdown();
    }
}
```

#### 任务3.3.3：实现任务管理接口
**描述**：实现任务管理的REST API接口

**实现要求**：
```java
// TaskController.java
@RestController
@RequestMapping("/api/tasks")
@PreAuthorize("hasRole('USER')")
public class TaskController {
    
    @Autowired
    private CollectionTaskService taskService;
    
    @PostMapping
    @PreAuthorize("hasPermission('task', 'create')")
    public ApiResponse<CollectionTask> createTask(@Valid @RequestBody TaskCreateRequest request) {
        CollectionTask task = taskService.createTask(request);
        return ApiResponse.success(task);
    }
    
    @GetMapping
    @PreAuthorize("hasPermission('task', 'view')")
    public ApiResponse<Page<CollectionTask>> getTasks(@ModelAttribute TaskQueryRequest request) {
        Page<CollectionTask> tasks = taskService.getTasks(request);
        return ApiResponse.success(tasks);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('task', 'view')")
    public ApiResponse<CollectionTask> getTask(@PathVariable Long id) {
        CollectionTask task = taskService.getTaskById(id);
        return ApiResponse.success(task);
    }
    
    @PostMapping("/{id}/execute")
    @PreAuthorize("hasPermission('task', 'execute')")
    public ApiResponse<Void> executeTask(@PathVariable Long id) {
        taskService.executeTask(id);
        return ApiResponse.success(null);
    }
    
    @PutMapping("/{id}/status")
    @PreAuthorize("hasPermission('task', 'update')")
    public ApiResponse<Void> updateTaskStatus(@PathVariable Long id, 
                                            @RequestBody TaskStatusUpdateRequest request) {
        taskService.updateTaskStatus(id, request.getStatus());
        return ApiResponse.success(null);
    }
    
    @GetMapping("/{id}/logs")
    @PreAuthorize("hasPermission('task', 'view')")
    public ApiResponse<Page<CollectionLog>> getTaskLogs(@PathVariable Long id,
                                                       @ModelAttribute LogQueryRequest request) {
        Page<CollectionLog> logs = taskService.getTaskLogs(id, request);
        return ApiResponse.success(logs);
    }
}
```

---

## 4. 第三阶段：监控与报警功能（2周）

### 4.1 实时数据推送 [P1] - 3天

#### 任务4.1.1：实现WebSocket配置和处理器
**描述**：实现WebSocket实时数据推送功能

**实现要求**：
```java
// WebSocketConfig.java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MonitoringWebSocketHandler(), "/ws/monitoring")
                .setAllowedOrigins("*")
                .addInterceptors(new WebSocketInterceptor());
    }
}

// MonitoringWebSocketHandler.java
@Component
public class MonitoringWebSocketHandler extends TextWebSocketHandler {
    
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String userId = getUserIdFromSession(session);
        sessions.put(userId, session);
        
        // 发送连接成功消息
        sendMessage(session, WebSocketMessage.builder()
            .type("CONNECTION_ESTABLISHED")
            .data("连接成功")
            .build());
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        String userId = getUserIdFromSession(session);
        sessions.remove(userId);
    }
    
    public void pushDeviceStatus(Long deviceId, DeviceStatus status) {
        WebSocketMessage message = WebSocketMessage.builder()
            .type("DEVICE_STATUS_UPDATE")
            .data(Map.of("deviceId", deviceId, "status", status))
            .timestamp(System.currentTimeMillis())
            .build();
        
        broadcastMessage(message);
    }
    
    public void pushCollectionData(Long deviceId, String metricName, Object value) {
        WebSocketMessage message = WebSocketMessage.builder()
            .type("COLLECTION_DATA")
            .data(Map.of(
                "deviceId", deviceId,
                "metricName", metricName,
                "value", value,
                "timestamp", System.currentTimeMillis()
            ))
            .build();
        
        broadcastMessage(message);
    }
    
    private void broadcastMessage(WebSocketMessage message) {
        String messageJson = JsonUtils.toJson(message);
        sessions.values().forEach(session -> {
            try {
                if (session.isOpen()) {
                    session.sendMessage(new TextMessage(messageJson));
                }
            } catch (Exception e) {
                log.error("Failed to send WebSocket message", e);
            }
        });
    }
}
```

### 4.2 报警管理系统 [P1] - 4天

#### 任务4.2.1：实现报警规则管理
**描述**：实现报警规则的创建、配置和管理

**实现要求**：
```java
// AlertRule.java
@Entity
@Table(name = "tb_alert_rules")
public class AlertRule {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    private String description;
    
    @Column(name = "device_type_id")
    private Long deviceTypeId;
    
    @Column(name = "metric_name")
    private String metricName;
    
    @Column(name = "condition_type", nullable = false)
    private String conditionType; // GT, LT, EQ, NE, IN, CONTAINS
    
    @Column(name = "threshold_value")
    private BigDecimal thresholdValue;
    
    @Type(JsonType.class)
    @Column(name = "threshold_config", columnDefinition = "jsonb")
    private Map<String, Object> thresholdConfig;
    
    @Column(nullable = false)
    private String level; // CRITICAL, HIGH, MEDIUM, LOW
    
    private Boolean enabled = true;
    
    // 其他字段...
}

// AlertRuleService.java
@Service
@Transactional
public class AlertRuleService {
    
    public AlertRule createRule(AlertRuleCreateRequest request) {
        // 验证规则配置
        validateRuleConfig(request);
        
        AlertRule rule = new AlertRule();
        rule.setName(request.getName());
        rule.setDescription(request.getDescription());
        rule.setDeviceTypeId(request.getDeviceTypeId());
        rule.setMetricName(request.getMetricName());
        rule.setConditionType(request.getConditionType());
        rule.setThresholdValue(request.getThresholdValue());
        rule.setLevel(request.getLevel());
        rule.setEnabled(true);
        
        rule = alertRuleRepository.save(rule);
        
        // 注册到报警引擎
        alertEngine.registerRule(rule);
        
        return rule;
    }
    
    public void evaluateRules(Long deviceId, String metricName, Object value) {
        // 获取适用的报警规则
        List<AlertRule> applicableRules = getApplicableRules(deviceId, metricName);
        
        for (AlertRule rule : applicableRules) {
            if (evaluateCondition(rule, value)) {
                triggerAlert(rule, deviceId, value);
            }
        }
    }
    
    private boolean evaluateCondition(AlertRule rule, Object value) {
        switch (rule.getConditionType()) {
            case "GT":
                return compareNumeric(value, rule.getThresholdValue()) > 0;
            case "LT":
                return compareNumeric(value, rule.getThresholdValue()) < 0;
            case "EQ":
                return Objects.equals(value.toString(), rule.getThresholdValue().toString());
            // 其他条件类型...
            default:
                return false;
        }
    }
    
    private void triggerAlert(AlertRule rule, Long deviceId, Object triggerValue) {
        // 创建报警记录
        Alert alert = new Alert();
        alert.setRuleId(rule.getId());
        alert.setDeviceId(deviceId);
        alert.setTitle(rule.getName());
        alert.setDescription(buildAlertDescription(rule, triggerValue));
        alert.setLevel(rule.getLevel());
        alert.setStatus("PENDING");
        alert.setTriggerValue(new BigDecimal(triggerValue.toString()));
        alert.setThresholdValue(rule.getThresholdValue());
        alert.setTriggerTime(new Timestamp(System.currentTimeMillis()));
        
        alert = alertRepository.save(alert);
        
        // 发送通知
        alertNotificationService.sendNotification(alert);
        
        // 推送到前端
        webSocketHandler.pushAlert(alert);
    }
}
```

#### 任务4.2.2：实现报警处理功能
**描述**：实现报警的查看、处理、确认等功能

**实现要求**：
```java
// AlertService.java
@Service
@Transactional
public class AlertService {
    
    public Page<Alert> getAlerts(AlertQueryRequest request) {
        Specification<Alert> spec = (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (request.getLevel() != null) {
                predicates.add(criteriaBuilder.equal(root.get("level"), request.getLevel()));
            }
            
            if (request.getStatus() != null) {
                predicates.add(criteriaBuilder.equal(root.get("status"), request.getStatus()));
            }
            
            if (request.getDeviceId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("deviceId"), request.getDeviceId()));
            }
            
            if (request.getStartTime() != null && request.getEndTime() != null) {
                predicates.add(criteriaBuilder.between(root.get("triggerTime"), 
                    request.getStartTime(), request.getEndTime()));
            }
            
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
        
        Pageable pageable = PageRequest.of(
            request.getPage() - 1, 
            request.getSize(),
            Sort.by(Sort.Direction.DESC, "triggerTime")
        );
        
        return alertRepository.findAll(spec, pageable);
    }
    
    public void processAlert(Long alertId, AlertProcessRequest request) {
        Alert alert = alertRepository.findById(alertId)
            .orElseThrow(() -> new BusinessException("报警不存在"));
        
        if (!"PENDING".equals(alert.getStatus())) {
            throw new BusinessException("报警已被处理");
        }
        
        // 更新报警状态
        alert.setStatus("PROCESSING");
        alert.setProcessedBy(getCurrentUserId());
        alert.setProcessedAt(new Timestamp(System.currentTimeMillis()));
        alert.setProcessNote(request.getProcessNote());
        
        alertRepository.save(alert);
        
        // 记录处理日志
        operationLogService.log("ALERT", "PROCESS", alertId, "处理报警");
        
        // 推送状态更新
        webSocketHandler.pushAlertStatusUpdate(alert);
    }
    
    public void resolveAlert(Long alertId, AlertResolveRequest request) {
        Alert alert = alertRepository.findById(alertId)
            .orElseThrow(() -> new BusinessException("报警不存在"));
        
        alert.setStatus("RESOLVED");
        alert.setResolvedTime(new Timestamp(System.currentTimeMillis()));
        alert.setResolution(request.getResolution());
        
        alertRepository.save(alert);
        
        // 记录操作日志
        operationLogService.log("ALERT", "RESOLVE", alertId, "解决报警");
    }
    
    public AlertStatistics getAlertStatistics() {
        return AlertStatistics.builder()
            .criticalCount(alertRepository.countByLevelAndStatus("CRITICAL", "PENDING"))
            .highCount(alertRepository.countByLevelAndStatus("HIGH", "PENDING"))
            .mediumCount(alertRepository.countByLevelAndStatus("MEDIUM", "PENDING"))
            .lowCount(alertRepository.countByLevelAndStatus("LOW", "PENDING"))
            .totalPending(alertRepository.countByStatus("PENDING"))
            .totalProcessing(alertRepository.countByStatus("PROCESSING"))
            .totalResolved(alertRepository.countByStatus("RESOLVED"))
            .build();
    }
}
```

### 4.3 历史数据查询 [P1] - 2天

#### 任务4.3.1：实现历史数据查询接口
**描述**：实现采集数据和操作日志的历史查询功能

**实现要求**：
```java
// HistoryService.java
@Service
public class HistoryService {
    
    public Page<CollectionData> getCollectionHistory(HistoryQueryRequest request) {
        Specification<CollectionData> spec = (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (request.getDeviceId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("deviceId"), request.getDeviceId()));
            }
            
            if (request.getMetricName() != null) {
                predicates.add(criteriaBuilder.equal(root.get("metricName"), request.getMetricName()));
            }
            
            if (request.getStartTime() != null && request.getEndTime() != null) {
                predicates.add(criteriaBuilder.between(root.get("collectedAt"), 
                    request.getStartTime(), request.getEndTime()));
            }
            
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
        
        Pageable pageable = PageRequest.of(
            request.getPage() - 1, 
            request.getSize(),
            Sort.by(Sort.Direction.DESC, "collectedAt")
        );
        
        return collectionDataRepository.findAll(spec, pageable);
    }
    
    public List<TimeSeriesData> getTimeSeriesData(TimeSeriesQueryRequest request) {
        // 构建时间序列查询
        return collectionDataRepository.findTimeSeriesData(
            request.getDeviceId(),
            request.getMetricName(),
            request.getStartTime(),
            request.getEndTime(),
            request.getInterval()
        );
    }
    
    public Page<OperationLog> getOperationLogs(LogQueryRequest request) {
        // 操作日志查询实现
        return operationLogRepository.findAll(buildLogSpec(request), 
            buildPageable(request));
    }
}

// HistoryController.java
@RestController
@RequestMapping("/api/history")
@PreAuthorize("hasRole('USER')")
public class HistoryController {
    
    @GetMapping("/collection-data")
    @PreAuthorize("hasPermission('history', 'view')")
    public ApiResponse<Page<CollectionData>> getCollectionHistory(
            @ModelAttribute HistoryQueryRequest request) {
        Page<CollectionData> data = historyService.getCollectionHistory(request);
        return ApiResponse.success(data);
    }
    
    @GetMapping("/time-series")
    @PreAuthorize("hasPermission('history', 'view')")
    public ApiResponse<List<TimeSeriesData>> getTimeSeriesData(
            @ModelAttribute TimeSeriesQueryRequest request) {
        List<TimeSeriesData> data = historyService.getTimeSeriesData(request);
        return ApiResponse.success(data);
    }
    
    @GetMapping("/operation-logs")
    @PreAuthorize("hasPermission('history', 'view')")
    public ApiResponse<Page<OperationLog>> getOperationLogs(
            @ModelAttribute LogQueryRequest request) {
        Page<OperationLog> logs = historyService.getOperationLogs(request);
        return ApiResponse.success(logs);
    }
}
```

---

## 5. 第四阶段：系统完善与优化（2周）

### 5.1 系统配置管理 [P2] - 3天

#### 任务5.1.1：实现系统配置功能
**描述**：实现系统参数的配置和管理

**实现要求**：
```java
// SystemSettingService.java
@Service
@Transactional
public class SystemSettingService {
    
    @Cacheable(value = "system_settings", key = "#groupName + '_' + #keyName")
    public String getSetting(String groupName, String keyName) {
        return systemSettingRepository.findByGroupNameAndKeyName(groupName, keyName)
            .map(SystemSetting::getValue)
            .orElse(null);
    }
    
    @CacheEvict(value = "system_settings", key = "#groupName + '_' + #keyName")
    public void updateSetting(String groupName, String keyName, String value) {
        SystemSetting setting = systemSettingRepository.findByGroupNameAndKeyName(groupName, keyName)
            .orElseThrow(() -> new BusinessException("配置项不存在"));
        
        // 验证配置值
        validateSettingValue(setting, value);
        
        setting.setValue(value);
        setting.setUpdatedBy(getCurrentUserId());
        setting.setUpdatedAt(new Timestamp(System.currentTimeMillis()));
        
        systemSettingRepository.save(setting);
        
        // 发布配置更新事件
        applicationEventPublisher.publishEvent(new SettingUpdateEvent(groupName, keyName, value));
    }
    
    public Map<String, Map<String, String>> getAllSettings() {
        List<SystemSetting> allSettings = systemSettingRepository.findAll();
        
        return allSettings.stream()
            .collect(Collectors.groupingBy(
                SystemSetting::getGroupName,
                Collectors.toMap(
                    SystemSetting::getKeyName,
                    SystemSetting::getValue
                )
            ));
    }
}
```

### 5.2 性能优化 [P2] - 4天

#### 任务5.2.1：实现缓存策略
**描述**：实现多级缓存提升系统性能

**实现要求**：
```java
// CacheConfig.java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());
        
        // 配置不同的缓存策略
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        
        // 设备信息缓存 - 30分钟
        cacheConfigurations.put("devices", 
            cacheConfiguration().entryTtl(Duration.ofMinutes(30)));
        
        // 系统配置缓存 - 1小时
        cacheConfigurations.put("system_settings", 
            cacheConfiguration().entryTtl(Duration.ofHours(1)));
        
        // 用户信息缓存 - 15分钟
        cacheConfigurations.put("users", 
            cacheConfiguration().entryTtl(Duration.ofMinutes(15)));
        
        return builder.withInitialCacheConfigurations(cacheConfigurations).build();
    }
}

// DeviceService中添加缓存注解
@Service
public class DeviceService {
    
    @Cacheable(value = "devices", key = "#deviceId")
    public Device getDeviceById(Long deviceId) {
        return deviceRepository.findById(deviceId).orElse(null);
    }
    
    @CacheEvict(value = "devices", key = "#device.id")
    public Device updateDevice(Device device) {
        return deviceRepository.save(device);
    }
    
    @Cacheable(value = "device_statistics")
    public DeviceStatusStatistics getDeviceStatistics() {
        // 统计查询逻辑
    }
}
```

#### 任务5.2.2：实现异步处理优化
**描述**：优化耗时操作的异步处理

**实现要求**：
```java
// AsyncConfig.java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean("taskExecutor")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("SkyEye-Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean("collectionExecutor")
    public TaskExecutor collectionExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("Collection-");
        executor.initialize();
        return executor;
    }
}

// 异步处理服务
@Service
public class AsyncProcessingService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processAlertNotification(Alert alert) {
        // 异步处理报警通知
        return CompletableFuture.completedFuture(null);
    }
    
    @Async("collectionExecutor")
    public CompletableFuture<CollectionResult> executeCollectionAsync(Device device, MetricConfig config) {
        // 异步执行数据采集
        CollectionResult result = collectorEngine.executeCollection(device, config);
        return CompletableFuture.completedFuture(result);
    }
}
```

### 5.3 监控和运维功能 [P2] - 3天

#### 任务5.3.1：实现健康检查
**描述**：实现系统健康检查和监控指标

**实现要求**：
```java
// CustomHealthIndicator.java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public Health health() {
        Health.Builder builder = Health.up();
        
        // 检查数据库连接
        try {
            Connection connection = dataSource.getConnection();
            connection.close();
            builder.withDetail("database", "UP");
        } catch (Exception e) {
            builder.down().withDetail("database", "DOWN: " + e.getMessage());
        }
        
        // 检查Redis连接
        try {
            redisTemplate.opsForValue().get("health_check");
            builder.withDetail("redis", "UP");
        } catch (Exception e) {
            builder.down().withDetail("redis", "DOWN: " + e.getMessage());
        }
        
        // 检查采集器状态
        long onlineCollectors = collectorRepository.countByStatus(1);
        long totalCollectors = collectorRepository.count();
        builder.withDetail("collectors", onlineCollectors + "/" + totalCollectors);
        
        return builder.build();
    }
}

// MetricsCollector.java
@Component
public class MetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Counter deviceStatusChangeCounter;
    private final Timer collectionTimer;
    
    public MetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.deviceStatusChangeCounter = Counter.builder("device.status.change")
            .description("Device status change events")
            .register(meterRegistry);
        this.collectionTimer = Timer.builder("collection.duration")
            .description("Data collection duration")
            .register(meterRegistry);
    }
    
    @EventListener
    public void handleDeviceStatusChange(DeviceStatusChangeEvent event) {
        deviceStatusChangeCounter.increment(
            Tags.of(
                "device_type", event.getDeviceType(),
                "old_status", event.getOldStatus().name(),
                "new_status", event.getNewStatus().name()
            )
        );
    }
    
    public void recordCollectionTime(Duration duration, String pluginType, boolean success) {
        collectionTimer.record(duration, 
            Tags.of(
                "plugin_type", pluginType,
                "success", String.valueOf(success)
            )
        );
    }
}
```

---

## 6. 开发规范和质量保证

### 6.1 代码规范要求
- 使用统一的代码格式化规则
- 所有公共方法必须有Javadoc注释
- 异常处理必须记录日志
- 数据库操作必须使用事务
- 敏感操作必须记录操作日志

### 6.2 测试要求
- 每个Service类必须有对应的单元测试
- 关键业务逻辑测试覆盖率不低于80%
- 所有Controller接口必须有集成测试
- 数据库操作必须有事务测试

### 6.3 部署要求
- 使用Docker容器化部署
- 配置文件使用环境变量
- 实现优雅关闭
- 支持健康检查

---

## 7. 总结

本任务分解文档将项目分为4个阶段，共11周的开发周期。每个任务都包含详细的实现要求和代码示例，确保开发工具能够理解并实现。

重点突出了设备管理、任务调度、数据采集等核心功能的优先级，确保系统核心功能优先完成。

所有任务都遵循Spring Boot最佳实践，使用标准的分层架构，便于维护和扩展。 